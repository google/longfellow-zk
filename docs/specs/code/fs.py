#
# Runs in sage if the pycryptodome package is installed in the environment.
#   `sage --pip install pycryptodome`
# To run this test in sage, run `sage --python fs.py`
#
from Crypto.Cipher import AES

import hashlib
import struct
import math

def hash(data):
    assert isinstance(data, bytes), "data not bytes"
    return hashlib.sha256(data).digest()

class FSPRF:
    """
    Fiat-Shamir Pseudorandom Function object.
    Produces an infinite stream of bytes organized in 16-byte blocks.
    Block i = AES256(SEED, ID(i))
    """
    def __init__(self, seed: bytes):
        assert len(seed) == 32, "Seed must be 32 bytes (AES-256 key size)."
        self.counter = 0
        self.buffer = bytearray()
        self.cipher = AES.new(seed, AES.MODE_ECB)

    def bytes(self, n: int) -> bytes:
        """Returns the next n bytes in the stream."""
        # Fill buffer until we have enough bytes
        while len(self.buffer) < n:
            # block_id is the 16-byte little-endian representation of integer i
            block_id = self.counter.to_bytes(16, 'little')
            
            # Block i = AES256(SEED, ID(i))
            block_output = self.cipher.encrypt(block_id)
            
            self.buffer.extend(block_output)
            self.counter += 1

        # Consume n bytes from the front of the buffer
        result = self.buffer[:n]
        self.buffer = self.buffer[n:]
        return bytes(result)


class Transcript:
    def __init__(self):
        self.tr = bytearray()
        self._is_initialized = False
        self._fs = None
        self._tr_snapshot_len = 0

    def init(self, session_id: bytes):
        """
        Initializes the transcript with a session_id.
        Must be called exactly once before any other method.
        """
        assert not self._is_initialized, "Transcript.init() must be called exactly once."
        self._is_initialized = True
        self.write_bytes(session_id)

    def write_field(self, elt, sz = 32):
        assert self._is_initialized, "init not called"       
        self.tr.append(0x01)
        self.tr.extend( int(elt).to_bytes(sz, byteorder="little"))

    def write_bytes(self, b):
        assert self._is_initialized, "init not called"       
        self.tr.append(0x00)
        # packs an unsigned long long (8 bytes) in Little Endian (<)
        length_prefix = struct.pack('<Q', len(b))
        self.tr.extend(length_prefix)
        self.tr.extend(b)

    def write_field_element_array(self, elems, sz=32):
        """
        Spec: Append byte designator 0x3, 8-byte LE count, then serialized elements.
        """
        assert self._is_initialized, "init not called"       
        self.tr.append(0x02)
        count_prefix = struct.pack('<Q', len(elems))
        self.tr.extend(count_prefix)
        
        for elem in elems:
            self.tr.extend( int(elem).to_bytes(sz, byteorder="little"))


    def _get_fs(self) -> FSPRF:
        """
        Retrieves the current FSPRF object.
        If 'write' has been called since the last retrieval, a new FSPRF
        is seeded using H(tr).
        """
        assert self._is_initialized, "init not called"       
        # If the transcript has changed, create a new FSPRF.        
        if self._fs is None or len(self.tr) != self._tr_snapshot_len:
            # Spec: "Next, a seed is generated by applying the function H to the (entire) string tr."
            seed = hash(bytes(self.tr))
            self._fs = FSPRF(seed)
            self._tr_snapshot_len = len(self.tr)
            
        return self._fs

    def generate_nat(self, m):
        """
        Generates a random natural number between 0 and m-1 inclusive via rejection sampling.
        """
        assert m > 0, "m must be > 0"

        l = m.bit_length()
        nbytes = math.ceil(l / 8)        
        mask = (1 << l) - 1 # Bitmask to isolate lower l bits
        fs = self._get_fs()
        while True:
            b = fs.bytes(nbytes)            
            k = int.from_bytes(b, 'little')            
            r = k & mask            
            if r < m:
                return r

    def generate_field(self, p):
        fs = self._get_fs()
        sz = math.ceil(p.bit_length() / 8)
        while True:
            b = fs.bytes(sz)
            x = int.from_bytes(b, byteorder='little', signed=False)
            if x < p:
                return x

    def generate_nats_wo_replacement(self, m, n):
        assert m > n, "invalid parameter"
        A = list(range(0, m))
        for i in range(0, n):
            j = i + self.generate_nat(m - i)
            A[i], A[j] = A[j], A[i]
        return A[:n]	
